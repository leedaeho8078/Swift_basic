# 속성(Property)

1. 속성(property)    
   * 저장 속성(stored), 지연(lazy) 저장 속성
   * 계산 속성(computed) - 읽기/쓰기
   * 타입 속성(type) - 저장/계산
   * 속성 감시자(property observer) - wiilSet/didSet

2. 메서드(method)
   * 인스턴스 메서드(instance method)
   * 타입 메서드(type method)
   * 서브스크립트(subscripts)
   * 생성자
       *  지정생성자(Designdated)
       *  편의생성자(Convenience)
       *  필수생성자(Required)
       *  실패가능생성자(Failable)
   * 소멸자
  

### 저장 속성
> 값이 저장되는 일반적인 속성을 저장 속성이라고 함      
> 저장 속성 ====> 구조체,클래스 동일

* 클래스/구조체의 틀에서 찍어낸 각 인스턴스가 가지는 고유의 데이터 저장 공간
* 변수나 상수로 선언 가능
* 객체의 초기화 시,각 `저장 속성`은 반드시 값을 가져야 함
  -> 기본값을 설정하거나 또는 생성자를 통해 설정 또는 옵셔널 타입으로 선언하여 nil을 초기값으로 갖는 것 가능
* 열거형의 경우 따로 메모리 공간이 필요한 저장 속성(데이터)은 선언할 수 없음
* **저장 속성(변수)은 각 속성자체가 고유의 메모리 공간을 가짐**

```Swift

class/struct Bird {
  var name: String            // 저장속성
  var weight: Double          // 저장속성

  init(name:String, weight: Double) {
    self.name = name
    self.weight = weight
  }

  func fly() {
    print("날아 갑니다")
  }


}

```


### 지연 저장 속성
> Lazy stored Properties     
> 지연 저장 속성은 "선언시점에 기본값을 저장"해야함


* 처음부터 메모리 공간을 가지지 않는다
* 해당 속성이 반드시 처음부터 초기화 필요하지 않은 경우(일반적으로 많은 메모리 공간을 차지하는 이미지 등)초기화를 지연시킴
  * 불필요한 성능 저하나, 메모리 공간의 낭비를 줄일 수 있다
* 값에 대한 접근이 있어야 초기화 -> 메모리 공간 생성
* lazy var로만 선언(lazy let 안됨) : 변화하는거랑 변수랑 비슷한 느낌이라 변수로만 선언가능
* 생성자에서 초기화하지 않기 떄문에 반드시 기본값이 필요
  -> 기본값은 표현식의 어떤 형태든 return 값만 일치하면 가능(함수 실행문, 계산식, 클로저 실행문 등)

지연 저장 속성의 2가지 이유
1. 메모리 공간의 낭비를 막을 수 있다.
2. 지연 저장 속성으로 선언되는 속성이 다른 저장 속성을 이용해야할떄
  -> (초기화 시점이 더 늦으므로, 먼저 초기화되는 저장 속성을 사용 가능)

### 계산 속성
- 속성의 형태를 가진 실질적 메서드
- 메서드이기 때문에 인스턴스에 메모리 공간이 할당되어 있지 않음
- var로만 선언 가능, 자로형까지 선언해야함(형식 추론 방식안됨)
- get블록만 선언하면 읽기전용(read-only)계산 속성이 됨(필수), set은 선택
- set은 선택, set만 구현하는 것은 불가능
- set블록에서 기본 파라미터 -> newValue가 제공됨(직접 파라미터 이름 설정 가능)

```Swift
class Person {
  var name = "사람"
  var h = 160.0
  var w = 60.0

  var bmi: Double {
    get {
      let bmi = w / (h * h) * 100000
      return bmi
    }
    set {
      w = newValue * h * h / 100000
    }

p.bmi // get
p.bmi = 25 // set
}

```
* 계산 속성 이해하기
* 메서드가 아닌. 속성방식으로 구현하면 무슨 장점이 있을까?
* 관련이 있는 두가지 메서드(함수)를 한번에 구현할수 있다.
* 속성이름으로 설정 가능하므로 보다 명확해 보임
* 메서드를 개발자들이 보다 읽기 쉽고, 명확하게 쓸수 있는 형태인 속성으로 변환해 놓은 것이다.
* 가장 중요한 것은 : 살졔로 `계산 속성`은 겉모습은 `속성형태를 가진 메서드(함수임)`
* 계산 속성은 실제 메모리 공간을 가지지 않고, 해당 속성에 접근했을떄 다른 속성에 접근해서 계산한 후, 그 계산결과를 리턴하거나 세팅하는 메서드이다.


### 타입 속성
* 인스턴스에 속한 속성이 아니고, 타입자체에 속한 속성이기에 **내/외부**에서 `Type.property`로 접근해야 한다.
* 저장 타입 속성을 주로 사용, `static -> 고정한/고정하는`


1. 저장 타입 속성
* 모든 인스터스가 동일하게 가져야하는 `보편적인 속성`이거나, 모든 인스턴스가 `공유해야하는 성격`에 가까운 저장속성을 `저장 타입 속성`으로 선언
* staic 키워드 사용.(상속시 -> 재정의 불가)(메서드만 상속이 가능 - class 키워드 사용 불가)
* let/var 선언 둘다 가능(저장 타입 속성)
* **항상 기본값(초기화)필요** -> 생성자에 의한 설정 과정이 없으므로
* 자체적으로 지연(Lazy) 속성의 성격을 가지므로, 호출시 메모리 할당(내부적으로 `Thread-Safe` 처리)

2. 계산 타입 속성
* (상속 시) 재정의 가능(class 키워드 사용 시에만)
* statci 또는 class 키워드 사용(static 상속 시 재정의 불가/class 상속 시 재정의 가능 의미)
* var 키워드만 사용(계산 타입 속성)
* 메서드이기 떄문에 메모리 공간이 할당되어 있지 않음(계산 속성)


```Swift
class Circle {
  static let pi = 3.145  // 저장 타입 속성
  static var count = 0   // 저장 타입 속성

  static var multiPly: Double {
      return (Ciricle).pi * 2    //계산 타입 속성
  }

}
```
  
### 속성 감시자
* 속성 감시자 - 1) willset -> 새 값이 저장되기 직전에 호출/ 2) didSet -> 새 값이 저장된 직 후에 호출됨 
* 저장속성 자체는 var로만 선언 가능(let은 관찰필요 없음, `지연저장 속성`은 관찰 안됨)
* 자로형을 선언하는 것은 일반 변수와 동일(기본값을 넣으면 형식 추론 방식 가능함)
* `저장 속성`의 변화시점을 관찰하는 실질적 메서드(타입/인스턴스 둘다 가능은 함)
* willSet 또는 didSet 중에서 한가지만 구현 하면됨(일반적으로 `didSet`으로 구현)
* 변수가 변하면, 업데이트 하려는 패턴 구현할떄 사용(예시: 상태메세지, 프로필 사진 -> 바로 화면 업데이트)
* 속성감시자 추가 가능한 경우(인스턴스 속성)
    * 저장 속성(상속한 저장속성은 재정의 불가, 감시자 추가는 가능)
    * 상속한 계산 속성을 재정의해 속성관찰자 추가 가능(단순 메서드 추가일뿐) -> 본래의 계산속성에는 setter의 값의 변경을 관찰가능 하므로 추가 불가)


```Swift
class Profile {
  var name: String = "이름"

  var statusMassage: String = "기본 상태메시지" {
      willSet {
        print("\(statusMassage)가 \(newValue)로 변경예정입니다.")
      }
      didSet {
        print("\(oldValue)가 \(statusMassage)로 변경되었습니다.")
      }

}

```
  

